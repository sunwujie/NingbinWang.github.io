---
layout:     post
title:      "漫谈android系统4"
subtitle:   " 点亮panel "
date:       2016-06-19 12:08:00
author:     "alex"
header-img: "img/post/post-android-4.jpg"
catalog: true
tags:
    - panel
    - android
    - mipi
---

## LCD

LCD 是指字面意思是液晶显示屏(Liquid Crystal Display), 而RAM: 随机存取存储器(Random-Access Memory）。控制IC是LCD的大脑。所谓的LCD RAM自然是指此大脑是否包含RAM.

LCD的种类分类标准比多，按驱动方式可以分为：被动矩阵式、主动矩阵式两种:

* 被动矩阵式：被动矩阵式LCD又可分为TN-LCD(TwistedNematic-LCD，扭曲向列LCD)、STN—LCD(SuperTN-LCD，超扭曲向列LCD)和DSTN-LCD(Doublelayer STN-LCD，双层超扭曲向列LCD).
* 主动矩阵式:目前应用比较广泛的主动矩阵式LCD，也称TFT-LCD。TFT-LCD 即是Thin-FilmTransistor Liquid-Crystal Display的缩写(薄膜电晶体液晶显示器)

TFT-LCD 结构侧视图 

![](https://raw.githubusercontent.com/NingbinWang/NingbinWang.github.io/master/img/post/mipi/mipi4.png)

其具体的物理定义请参照[Android LCD(一)：LCD基本原理篇 ](http://blog.csdn.net/xubin341719/article/details/9125583)

LCD传输的信号有很多：
* TTL（主要用于小屏）
* LVDS，即Low Voltage Differential Signaling，是一种低压差分信号技术接口。克服以TTL电平方式传输宽带高码率数据时功耗大、EMI电磁干扰大等缺点而研制的一种数字视频信号传输方式
* EDP
* MIPI（我主要对此有过研究，因此在这个接口上会详细讲述）

PS：基本上作为手机制造商来讲，会使用mipi作为接口，据我现在工作的华硕公司来讲，基本上使用的都是TM、BOE的panel。

想要了解其他的借口信号可以参考[Android LCD(二)：LCD常用接口原理篇](http://blog.csdn.net/xubin341719/article/details/9125799)

## MIPI

MIPI (Mobile Industry Processor Interface) 是2003年由ARM, Nokia, ST ,TI等公司成立的一个联盟，目的是把手机内部的接口如摄像头、显示屏接口、射频/基带接口等标准化，从而减少手机设计的复杂程度和增加设计灵活性。 MIPI联盟下面有不同的WorkGroup，分别定义了一系列的手机内部接口标准，比如摄像头接口CSI、显示接口DSI、射频接口DigRF、麦克风 /喇叭接口SLIMbus等。统一接口标准的好处是手机厂商根据需要可以从市面上灵活选择不同的芯片和模组，更改设计和功能时更加快捷方便。

下图是以mipi为例的手机内部框架图：

![](https://raw.githubusercontent.com/NingbinWang/NingbinWang.github.io/master/img/post/mipi/mipi1.jpg)

CSI/DSI分别是指其承载的是针对Camera或Display应用，都有复杂的协议结构。以DSI为例，其协议层结构如下：

![](https://raw.githubusercontent.com/NingbinWang/NingbinWang.github.io/master/img/post/mipi/mipi2.JPG)

DSI (Display Serial Interface)定义了一个位于处理器和显示模组之间的高速串行接口

DSI分四层，对应D-PHY、DSI、DCS规范

* PHY 定义了传输媒介，输入/输出电路和和时钟和信号机制。
* Lane Management层：发送和收集数据流到每条lane
* Low Level Protocol层：定义了如何组帧和解析以及错误检测等
* Application层：描述高层编码和解析数据流

屏幕传输中又对应的2种不同的传输模式：

* Command mode:对应传输的是mpu接口
* Video mode:对应的是RGB接口，这种传输数据方式只能通过hs mode进行传输

##### mipi传输模式

* LP(low-power低功耗)用于控制，采用单端信号 
* HS(high-speed)用于高速传输，采用低压差分信号 （抑制共模噪声）

对于LP与HS各个状态所代表的状态表

![](https://raw.githubusercontent.com/NingbinWang/NingbinWang.github.io/master/img/post/mipi/mipi3.png)

##### DSI时钟信号

DSI 时钟 Lanes 有三种模式 Low power mode（LPM），Ultra Low power mode（ULPM超低俗），High Speed Clock mode（HSCM） 
可以参照上表做分析：

![](https://raw.githubusercontent.com/NingbinWang/NingbinWang.github.io/master/img/post/mipi/mipi5.png)

这部分内容主要是看时钟信号，后面会具体整理后上传

小结：传输图像等数据是通过HSmode传输保证了数据的快速传递，而下相关的command去控制panel的寄存器就需要使用LPmode传输，可以保证数据的正确性。

## bring up panel

#####  拿到panel板子，首先问厂商要该板子的code，包括initial code，reset sequence ，porch setting。

![](https://raw.githubusercontent.com/NingbinWang/NingbinWang.github.io/master/img/post/mipi/mipi6.png)

图中相关信息
* step 1-7  电压配置，LP11 拉高。
* step 8-12  reset sequence （重要）
* step 13-18  on command 点亮屏幕


![](https://raw.githubusercontent.com/NingbinWang/NingbinWang.github.io/master/img/post/mipi/mipi7.jpg)

这个是上电的sequence，包括前面的电压配置（不同电压之间的延时），reset sequence ， MIPI data&clock  ， command  ，最后是数据传输


![](https://raw.githubusercontent.com/NingbinWang/NingbinWang.github.io/master/img/post/mipi/mipi8.jpg)

Porch setting 数据正如前面所说，是DSI video mode的Timing

##### 根据厂商panel 的 IC 和 code 计算timging ，填写xml文档。

从device\qcom\common\display\tools下找到panel-xxxx.xml文件里面包含主要有9个部分。

xml文件每个配置具体含义可以查看高通的[文档](https://github.com/NingbinWang/NingbinWang.github.io/documents/80-BA103-1_XMLTAGDESCRIPTIONFORDISPLAYMOD.pdf)

```
<!-- Panel Command information -->根据前面的initial code
<OnCommand><OffCommand>格式
      CommandType    Data type of command    1
      Last      Specifies if this command packet is individual or not.   1
      VC    Virtual channel used to send this command      1
      Ack   Needs acknowledgement from panel     1
      Wait  Sleep in microsecond before sending next  command.    1
      PayloadSize   Size of payload    2
      Payload   Actual command  Based on payload size
      example：
      0x29, 0x01, 0x00 ,0x00, 0x80, 0x00, 0x02, 0x11, 0x00
      <OnCommandState>   Panel state when sending the on command.
       0 = DSI_LP_MODE   1= DSI_HS_MODE
```

```
<!-- Panel Resolution -->根据上面porch setting
 PanelWidth =  Panel width in pixel  = 1080
PanelHeight = Panel height in pixel = 1920
HFrontPorch = Horizontal back porch value = HFP = 120
HBackPorch = Horizontal front porch value = HBP =  60
HPulseWidth = Horizontal pulse width = HS = 4
HSyncSkew = Horizontal sync skew value 厂商没有特殊说明 都为0
VBackPorch=Vertical back porch value = VBP = 4
VFrontPorch= Vertical front porch value = VFP = 4
VPulseWidth=Vertical pulse width = VS = 4
HLeftBorder      厂商没有特殊说明 都为0
HRightBorder    厂商没有特殊说明 都为0
VTopBorder       厂商没有特殊说明 都为0
VBottomBorder  厂商没有特殊说明 都为0 
Porch setting 设置完了。
```

```
<!-- Panel Timing -->使用高通的计算timging tool  80-NH7131_x.xlsm
在DSI and MDP registers 选项中
```
![](https://raw.githubusercontent.com/NingbinWang/NingbinWang.github.io/master/img/post/mipi/mipi9.jpg)

Frame rate 已知，lane config 4 ， pixel 3 (固定) ，clk 19.2 MHZ
Chip  8x56 ,其他如porch  setting 上。确认后点击check

在DSI PHY x  timing settings 选项中
![](https://raw.githubusercontent.com/NingbinWang/NingbinWang.github.io/master/img/post/mipi/mipi10.jpg)

```
如果出现INVALID的情况，通过改变T_CLK_PREPARE值使T_CLK_ZERO是VALID的，
计算公式是  (T_CLK_PREPARE+T_TCL_ZERO+T_HS_RQST)mod8 = 0
```

```
DSI PHY register 即为timing值。
<PanelTimings> 12位，最后一个为0x00
<TClkPost>为T_CLK_POST,<TClkPre>为T_CLK_PRE
```

```
<!-- Backlight -->
BLMinLevel        Minimum value of backlight       1
BLMaxLevel	   Maximum value of backlight     255
BLPMICControlType   PMIC controller for current backlight.
     0 = PWM GPIO   1 = WLED    2 = DCS COMMANDS    3 = LPG
    （看电路图          这个配置会影响到kernel的背光控制，一般使用WLED和DCS COMMAND ，若配置错误，系统调节背光不能使用）
     
     BLMinLevel 和 BLMaxLevel影响 backlight等级，设置1  - 255 控制背光范围较小，设置1 – 4095 控制背光范围较大
```

```
<!-- Panel Reset Sequence -->根据reset  sequence
<ResetSequence>
            <PinState1>1</PinState1>		
            <PulseWidth1>20</PulseWidth1>	
            <PinState2>0</PinState2>		
            <PulseWidth2>10</PulseWidth2>	
            <PinState3>1</PinState3>		
            <PulseWidth3>20</PulseWidth3>	
           <EnableBit>2</EnableBit>	 Reset pin direction to enable it     默认2
    </ResetSequence>
    设置时序延时。高电平->延时20ms->低电平->延时10ms->高电平->延时20ms
    
如果panel 电压不对，则在这里面改 
<!-- GPIO configuration -->查电路图看有哪些pin接上
<ResetGPIO>   Reset GPIO pin to reset the DSI panel
<EnableGPIO>  Enable GPIO pin to power on the DSI   panel
<TEGPIO>   TE pin for command mode panel
<PWMGPIO>  Reset sequence using ResetGPIO with  pulse width
<PinSource>“msmgpio”</PinSource>  一般固定string
<PinId>7</PinId>   Integer GPIO pin number on source location   看电路图
<PinStrength>3</PinStrength>      Power strength of GPIO pin mA. Value section describes the power strength table. 有  0=2mA 1=4mA  2=6mA  3=8mA  4=10mA  5=12mA  6=14mA  7=16mA
<PinDirection>1</PinDirection>    GPIO pin direction 输入\输出
 <PinPull>0</PinPull>   GPIO pin pull direction
<PinState>1</PinState> GPIO Pin active state    enable\disable
```

##### 通过Perl生成相对应的.h，和.dtsi文件，分别放在不同的目录，.h放在lk，.dtsi放在kernel里面。

```
     在device\qcom\common\display\toos\下执行command
      perl parser.pl   panel_*******.xml   panel  生成 .dtsi 和  .h两个文件
      perl parser.pl   platform_****.xml    platform 生成.dtsi 和 .h 两个文件
     .h文件用于lk点屏,  .dtsi文件用于kernel点屏
把panel的.h文件放到  bootable\bootloader\lk\dev\gcdb\display\include\目录下
      把platform的.h文件改成display.h放在bootable\bootloader\lk\target\msmxxxx\include\target下，或者直接target_display.c里面添加。(不同的chip和source code放的位置都不一样)

把panel的.dtsi文件放到 kernel\arch\arm64\boot\dts\qcom目录下
```

##### 点亮屏幕       点亮屏幕分lk和kernel两部分。  

```
bring up  LK  （添加不同的panel）
     1.把panel的.h文件放到  bootable\bootloader\lk\dev\gcdb\display\include\目录下
     2. 把platform的.h文件改成display.h放在bootable\bootloader\lk\target\msmxxxx\include\target下，或者直接target_display.c里面添加。(不同的chip和source code放的位置都不一样）
     3.在bootable\bootloader\lk\plaform\msmxxxx\gpio.c中添加int gpio_get函数，用来获取相对应gpio口的状态。
     4.在bootable\bootloader\lk\target\msmxxxx\init.c的target_init函数中给LCD_ID1和LCD_ID2所在的gpio口上电使能，即gpio_tlmm_config函数
     5.在bootable\bootloader\lk\target\msmxxxx\oem_panel.c中添加生成的.h头文件，selection variable 和 list，并通过switch函数把.h参数配置到相对应的数据结构中
     6.最后选择dsi_reg_mode(重要)，有两种mode，DCDC mode（默认）和LDO mode，要问ee，我们使用的是哪个mode。
```

```
bring up  kernel  （添加不同的panel）
	 1.在panel的.dtsi最后面添加  qcom,mdss-dsi-lp11-init;即时序中LP11初始化
	 2. 把panel的.dtsi文件放到 kernel\arch\arm64\boot\dts\qcom目录下
	 3.在kernel\arch\arm64\boot\dts\qcom\msmxxxx-mdss-panels.dtsi中添加.dtsi文件为头  文件,并把platform下.dtsi 的supply输入写到里面。
      4.在 kernel\arch\arm64\boot\dts\qcom\msmxxxx-mdss-mtp.dtsi中&mdss_dsi0中添加对应panel ID 和 .dtsi入口地址，把platform的.dtsi中gpio信息填到&mdss_dsi最后。

编译aboot  和   boot  ，烧入即可完成点屏
```

